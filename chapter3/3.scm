;3.12 (b) (b c d)
(define (append! x y) (set-cdr! (last-pair x) y) x)
(define (last-pair x) (if (null? (cdr x)) x (last-pair (cdr x))))
;3.13
(define (make-cycle x) (set-cdr! (last-pair x) x) x)
;3.14 a reverse function
(define (mystery x)
 (define (loop x y)
  (if (null? x) y
   (let ((temp (cdr x))) (set-cdr! x y) (loop temp x))))
 (loop x '()))
;3.15 i draw the box in my heart
;3.16
(define (count-pairs x) (if (not (pair? x)) 0 (+ (count-pairs (car x)) (count-pairs (cdr x)) 1)))
;3.17
(define (count-pairs x) (length (inner x '())))
(define (inner x memo-list)
 (if (and (pair? x) (false? (memq x memo-list)))
  (inner (car x) (inner (cdr x) (cons x memo-list))) memo-list))
;3.18 impressive
(define (loop? lst)
 (let ((identity (cons '() '())))
  (define (iter remain-list)
   	(cond   ((null? remain-list) #f)
	 		((eq? identity (car remain-list)) #t)
			(else (set-car! remain-list identity) (iter (cdr remain-list)))))
  (iter lst)))
;3.19
(define (loop-const? lst)
 (define (iter x y)
  (let ((x-walk (list-walk 1 x)) (y-walk (list-walk 2 y)))
     (cond  ((or (null? x-walk) (null? y-walk)) #f)
	  		((eq? x-walk y-walk) #t)
			(else (iter x-walk y-walk)))))
 (iter lst lst))
(define (list-walk step lst)
 (cond  ((null? lst) '())
  		((= step 0) lst)
		(else (list-walk (- step 1) (cdr lst)))))
;queue
(define make-queue (cons '() '()))
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))
(define (empty-queue? queue) (null? (front-ptr queue)))
(define (front-queue queue) (if (empty-queue? queue) (error "Front called with an empty queue" queue) 
							 (car (front-ptr queue))))
(define (insert-queue! queue item)
 (let ((new-pair (cons item '())))
  (cond ((empty-queue? queue) (set-front-ptr! queue new-pair) (set-rear-ptr! queue new-pair) queue)
   		(else (set-cdr! (rear-ptr queue) new-pair) (set-rear-ptr! queue new-pair) queue))))
(define (delete-queue! queue) (cond ((empty-queue? queue) (error "Delete called with an empty queue" queue))
			  					    (else (set-front-ptr! queue (cdr (front-ptr queue))) queue)))
;3.21
(define (print-queue queue) (front-ptr queue))
;3.22
(define (make-queue)
 (let ((front-ptr '()) (rear-ptr '()))
  (define (empty-queue?) (null? front-ptr))
  (define (set-front-ptr! item) (set! front-ptr item))
  (define (set-rear-ptr! item) (set! rear-ptr item))
  (define (insert-queue! item)
   (let ((new-pair (cons item '())))
	(cond ((empty-queue?) (set-front-ptr! new-pair) (set-rear-ptr! new-pair) front-ptr)
	 	  (else (set-cdr! rear-ptr new-pair) (set-rear-ptr! new-pair)))))
  (define (delete-queue!) (cond ((empty-queue?) (error "Delete called with an empty queue"))
						 	  (else (set-front-ptr! (cdr front-ptr)) front-ptr)))
  (define (dispatch m)
   (cond  ((eq? m 'insert-queue!) insert-queue!)
		  ((eq? m 'delete-queue!) delete-queue!)
		  (else (error "arg unmatched " m))))
  dispatch))
;3.23
(define (make-deque) (cons (cons '() '()) (cons '() '())))
(define (empty-deque? deque) (null? (car (front-deque deque))))
(define (front-deque deque) (car deque)) 
(define (rear-deque deque) (cdr deque))
(define (front-insert-deque! deque item)
 (let ((new-pair (cons item '())))
  (cond ((empty-deque? deque) 
		 (set-front-ptr! (front-deque deque) new-pair) (set-rear-ptr! (front-deque deque) new-pair)
		 (set-front-ptr! (rear-deque deque) new-pair) (set-rear-ptr! (rear-deque deque) new-pair) deque)
		(else (set-front-ptr! (front-deque deque) (cons item (car (front-deque deque))))
		 	  (set-cdr! (cdr (rear-deque deque)) new-pair)
		 	  (set-rear-ptr! (rear-deque deque) new-pair) deque))))
(define (rear-insert-deque! deque item)
 (let ((new-pair (cons item '())))
  (cond ((empty-deque? deque)
		 (set-front-ptr! (front-deque deque) new-pair) (set-rear-ptr! (front-deque deque) new-pair)
		 (set-front-ptr! (rear-deque deque) new-pair) (set-rear-ptr! (rear-deque deque) new-pair) deque)
   		(else (set-front-ptr! (rear-deque deque) new-pair) (set-cdr! (cdr (front-deque deque)) new-pair)
		 (set-rear-ptr! (front-deque deque) new-pair) deque))))
(define (front-delete-deque! deque)
 (cond  ((empty-deque? deque) (error "Delete called with an empty queue"))
  		(else (set-front-ptr! (front-deque deque) (rear-ptr (front-deque deque)))
		 	  (set-rear-ptr! (rear-deque deque) (front-ptr (front-deque deque))) (front-deque deque))))
;table
(define (lookup key table)
 (let ((record (assoc key (cdr table)))) (if record (cdr record) #f)))
(define (assoc key records)
 (cond  ((null? records) #f)
  		((equal? key (caar records)) (car records))
		(else (assoc key (cdr records)))))
(define (insert! key value table)
 (let ((record (assoc key (cdr table))))
  (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table)))))
 'ok)
(define (make-table) (list '*table*))
;2-dimensional table
(define (make-2-table)
 (let ((local-table (list '*table*)))
  (define (lookup key-1 key-2)
   (let ((subtable (assoc key-1 (cdr local-table))))
	(if subtable
	 (let ((record (assoc key-2 (cdr subtable))))
	  (if record (cdr record) #f))
	   #f)))
  (define (insert! key-1 key-2 value)
   (let ((subtable (assoc key-1 (cdr local-table))))
	(if subtable
	 (let ((record (assoc key-2 (cdr subtable))))
	  (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable)))))
	 (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table)))))
   'ok)
  (define (dispatch m)
   (cond  ((eq? m 'lookup-proc) lookup)
		  ((eq? m 'insert-proc!) insert!)
		  (else (error "Unknown operation " m))))
  dispatch))
(define operation-table (make-2-table))
(define get (operation-table 'lookup-proc))  ;impressive. It's oop
(define put (operation-table 'insert-proc!))
;3.24
(define (same-key? key-1 key-2) (< (abs (- key-1 key-2)) 0.01))
;3.25 3.26 too large. I would do that later
;3.27 error
(define (memoize f)
 (let ((table (make-table)))
  (lambda (x)
   (let ((previously-computed-result (lookup x table)))
	(or previously-computed-result
	 (let ((result (f x))) (insert! x result table) result))))))
(define memo-fib (memoize (lambda (n) 
						   (cond  ((= n 0) 0)
								  ((= n 1) 1)
								  (else (+ (memo-fib (- n 1)) (memo-fib (- n 2))))))))
(define (fib n) 
	   (cond  ((= n 0) 0)
			  ((= n 1) 1)
			  (else (+ (fib (- n 1)) (fib (- n 2))))))
;digital circuit
(define (half-adder a b s c)
 (let ((d (make-wire)) (e (make-wire)))
  (or-gate a b d)
  (and-gate a b c)
  (inverter c e)
  (and-gate d e s)
  'ok))
(define (full-adder a b c-in sum c-out)
 (let ((s (make-wire)) (c1 (make-wire)) (c2 (make-wire)))
  (half-adder b c-in s c1)
  (half-adder a c1 sum c2)
  (or-gate c1 c2 c-out)
  'ok))

