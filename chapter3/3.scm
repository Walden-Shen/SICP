;3.12 (b) (b c d)
(define (append! x y) (set-cdr! (last-pair x) y) x)
(define (last-pair x) (if (null? (cdr x)) x (last-pair (cdr x))))
;3.13
(define (make-cycle x) (set-cdr! (last-pair x) x) x)
;3.14 a reverse function
(define (mystery x)
 (define (loop x y)
  (if (null? x) y
   (let ((temp (cdr x))) (set-cdr! x y) (loop temp x))))
 (loop x '()))
;3.15 i draw the box in my heart
;3.16
(define (count-pairs x) (if (not (pair? x)) 0 (+ (count-pairs (car x)) (count-pairs (cdr x)) 1)))
;3.17
(define (count-pairs x) (length (inner x '())))
(define (inner x memo-list)
 (if (and (pair? x) (false? (memq x memo-list)))
  (inner (car x) (inner (cdr x) (cons x memo-list))) memo-list))
;3.18 impressive
(define (loop? lst)
 (let ((identity (cons '() '())))
  (define (iter remain-list)
   	(cond   ((null? remain-list) #f)
	 		((eq? identity (car remain-list)) #t)
			(else (set-car! remain-list identity) (iter (cdr remain-list)))))
  (iter lst)))
;3.19
(define (loop-const? lst)
 (define (iter x y)
  (let ((x-walk (list-walk 1 x)) (y-walk (list-walk 2 y)))
     (cond  ((or (null? x-walk) (null? y-walk)) #f)
	  		((eq? x-walk y-walk) #t)
			(else (iter x-walk y-walk)))))
 (iter lst lst))
(define (list-walk step lst)
 (cond  ((null? lst) '())
  		((= step 0) lst)
		(else (list-walk (- step 1) (cdr lst)))))
;queue
(define make-queue (cons '() '()))
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))
(define (empty-queue? queue) (null? (front-ptr queue)))
(define (front-queue queue) (if (empty-queue? queue) (error "Front called with an empty queue" queue) 
							 (car (front-ptr queue))))
(define (insert-queue! queue item)
 (let ((new-pair (cons item '())))
  (cond ((empty-queue? queue) (set-front-ptr! queue new-pair) (set-rear-ptr! queue new-pair) queue)
   		(else (set-cdr! (rear-ptr queue) new-pair) (set-rear-ptr! queue new-pair) queue))))
(define (delete-queue! queue) (cond ((empty-queue? queue) (error "Delete called with an empty queue" queue))
			  					    (else (set-front-ptr! queue (cdr (front-ptr queue))) queue)))
;3.21
(define (print-queue queue) (front-ptr queue))
;3.22
(define (make-queue)
 (let ((front-ptr '()) (rear-ptr '()))
  (define (empty-queue?) (null? front-ptr))
  (define (set-front-ptr! item) (set! front-ptr item))
  (define (set-rear-ptr! item) (set! rear-ptr item))
  (define (insert-queue! item)
   (let ((new-pair (cons item '())))
	(cond ((empty-queue?) (set-front-ptr! new-pair) (set-rear-ptr! new-pair) front-ptr)
	 	  (else (set-cdr! rear-ptr new-pair) (set-rear-ptr! new-pair)))))
  (define (delete-queue!) (cond ((empty-queue?) (error "Delete called with an empty queue"))
						 	  (else (set-front-ptr! (cdr front-ptr)) front-ptr)))
  (define (dispatch m)
   (cond  ((eq? m 'insert-queue!) insert-queue!)
		  ((eq? m 'delete-queue!) delete-queue!)
		  (else (error "arg unmatched " m))))
  dispatch))
;3.23
(define (make-deque) (cons (cons '() '()) (cons '() '())))
(define (empty-deque? deque) (null? (car (front-deque deque))))
(define (front-deque deque) (car deque)) 
(define (rear-deque deque) (cdr deque))
(define (front-insert-deque! deque item)
 (let ((new-pair (cons item '())))
  (cond ((empty-deque? deque) 
		 (set-front-ptr! (front-deque deque) new-pair) (set-rear-ptr! (front-deque deque) new-pair)
		 (set-front-ptr! (rear-deque deque) new-pair) (set-rear-ptr! (rear-deque deque) new-pair) deque)
		(else (set-front-ptr! (front-deque deque) (cons item (car (front-deque deque))))
		 	  (set-cdr! (cdr (rear-deque deque)) new-pair)
		 	  (set-rear-ptr! (rear-deque deque) new-pair) deque))))
(define (rear-insert-deque! deque item)
 (let ((new-pair (cons item '())))
  (cond ((empty-deque? deque)
		 (set-front-ptr! (front-deque deque) new-pair) (set-rear-ptr! (front-deque deque) new-pair)
		 (set-front-ptr! (rear-deque deque) new-pair) (set-rear-ptr! (rear-deque deque) new-pair) deque)
   		(else (set-front-ptr! (rear-deque deque) new-pair) (set-cdr! (cdr (front-deque deque)) new-pair)
		 (set-rear-ptr! (front-deque deque) new-pair) deque))))
(define (front-delete-deque! deque)
 (cond  ((empty-deque? deque) (error "Delete called with an empty queue"))
  		(else (set-front-ptr! (front-deque deque) (rear-ptr (front-deque deque)))
		 	  (set-rear-ptr! (rear-deque deque) (front-ptr (front-deque deque))) (front-deque deque))))
;table
(define (lookup key table)
 (let ((record (assoc key (cdr table)))) (if record (cdr record) #f)))
(define (assoc key records)
 (cond  ((null? records) #f)
  		((equal? key (caar records)) (car records))
		(else (assoc key (cdr records)))))
(define (insert! key value table)
 (let ((record (assoc key (cdr table))))
  (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table)))))
 'ok)
(define (make-table) (list '*table*))
;2-dimensional table
(define (make-2-table)
 (let ((local-table (list '*table*)))
  (define (lookup key-1 key-2)
   (let ((subtable (assoc key-1 (cdr local-table))))
	(if subtable
	 (let ((record (assoc key-2 (cdr subtable))))
	  (if record (cdr record) #f))
	   #f)))
  (define (insert! key-1 key-2 value)
   (let ((subtable (assoc key-1 (cdr local-table))))
	(if subtable
	 (let ((record (assoc key-2 (cdr subtable))))
	  (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable)))))
	 (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table)))))
   'ok)
  (define (dispatch m)
   (cond  ((eq? m 'lookup-proc) lookup)
		  ((eq? m 'insert-proc!) insert!)
		  (else (error "Unknown operation " m))))
  dispatch))
(define operation-table (make-2-table))
(define get (operation-table 'lookup-proc))  ;impressive. It's oop
(define put (operation-table 'insert-proc!))
;3.24
(define (same-key? key-1 key-2) (< (abs (- key-1 key-2)) 0.01))
;3.25 3.26 too large. I would do that later
;3.27 error
(define (memoize f)
 (let ((table (make-table)))
  (lambda (x)
   (let ((previously-computed-result (lookup x table)))
	(or previously-computed-result
	 (let ((result (f x))) (insert! x result table) result))))))
(define memo-fib (memoize (lambda (n) 
						   (cond  ((= n 0) 0)
								  ((= n 1) 1)
								  (else (+ (memo-fib (- n 1)) (memo-fib (- n 2))))))))
(define (fib n) 
	   (cond  ((= n 0) 0)
			  ((= n 1) 1)
			  (else (+ (fib (- n 1)) (fib (- n 2))))))
;digital circuit
(define (half-adder a b s c)
 (let ((d (make-wire)) (e (make-wire)))
  (or-gate a b d)
  (and-gate a b c)
  (inverter c e)
  (and-gate d e s)
  'ok))
(define (full-adder a b c-in sum c-out)
 (let ((s (make-wire)) (c1 (make-wire)) (c2 (make-wire)))
  (half-adder b c-in s c1)
  (half-adder a c1 sum c2)
  (or-gate c1 c2 c-out)
  'ok))
(define (inverter input output)
 (define (invert-input)
  (let ((new-value (logical-not (get-signal input))))
   (after-delay invert-delay (lambda () (set-signal! output new-value)))))
 (add-action! input invert-input)
 'ok)
(define (logical-not s)
 (cond  ((= s 0) 1)
  		((= s 1) 0)
		(else (error "Invalid signal" s))))
(define (and-gate a1 a2 output)
 (define (and-action-procedure)
  (let ((new-value (logical-and (get-signal a1) (get-signal a2))))
   (after-delay and-gate-delay (lambda () (set-signal! output new-value)))))
 (add-action! a1 and-action-procedure) (add-action! a2 and-action-procedure)
 'ok)
(define (logical-and s1 s2)
 (cond  ((and (= s1 1) (= s2 1)) 1)
  		((or (and (= s1 0) (= s2 1)) (and (= s1 1) (= s2 0)) (and (= s1 0) (= s2 0))) 0)
		(else (error "Invalid signal" s1 s2))))
;3.28
(define (or-gate a1 a2 output)
 (define (or-action-procedure)
  (let ((new-value (logical-or (get-signal a1) (get-signal a2))))
   (after-delay or-gate-delay (lambda () (set-signal! output new-value)))))
 (add-action! a1 or-action-procedure) (add-action! a2 or-action-procedure)
 'ok)
(define (logical-or s1 s2)
 (cond  ((and (= s1 0) (= s2 0)) 0)
  		((or (and (= s1 0) (= s2 1)) (and (= s1 1) (= s2 0)) (and (= s1 1) (= s2 1))) 1)
		(else (error "Invalid signal" s1 s2))))
;3.29
(define (compound-or-gate a1 a2 output)
 (define (compound-or-procedure)
  (let ((new-value (logical-not (logical-and (logical-not (get-signal a1)) (logical-not (get-signal a2))))))
   (after-delay or-gate-delay (lambda () (set-signal! output new-value)))))
 (add-action! a1 compound-or-procedure) (add-action! a2 compound-or-procedure)
 'ok)
(define (compound-or-gate a1 a2 output)
 (let ((b1 (make-wire)) (b2 (make-wire)) (c (make-wire)))
  (inverter a1 b1)
  (inverter a2 b2)
  (and-gate b1 b2 c)
  (inverter c output)
  'ok))
;3.30
(define (ripple-carry-adder list-A list-B list-S C)
 (define (iter A B S value-of-c)
  (if (and (null? A) (null? B) (null? S))
      'ok
	  (let ((Ak (car A)) (Bk (car B)) (Sk (car S)) (remain-A (cdr A)) (remain-B (cdr B)) (remain-S (cdr S)) (Ck (make-wire)))
	   (set-signal! Ck value-of-c)
	   (full-adder Ak Bk Ck Sk C)
	   (iter remain-A remain-B remain-S (get-signal C)))))
 (iter list-A list-B list-S (get-signal C)))
;wire
(define (make-wire)
 (let ((signal-value 0) (action-procedures '()))
  (define (set-my-signal! new-value)
   (if (not (= signal-value new-value)) (begin (set! signal-value new-value) (call-each action-procedures)) 'done))
  (define (accept-action-procedure! proc) (set! action-procedures (cons proc action-procedures)) (proc))
  (define (dispatch m)
   (cond  ((eq? m 'get-signal) signal-value)
		  ((eq? m 'set-signal!) set-my-signal!)
		  ((eq? m 'add-action!) accept-action-procedure!)
		  (else (error "Unknown operation" m))))
  dispatch))
(define (call-each procedures)
 (if (null? procedures) 'done (begin ((car procedures)) (call-each (cdr procedures)))))
(define (get-signal wire) (wire 'get-signal))
(define (set-signal! wire signal) ((wire 'set-signal!) signal))
(define (add-action! wire proc) ((wire 'add-action!) proc))
;agenda
(define (after-delay delay action) (add-to-agenda! (+ delay (current-time the-agenda)) action the-agenda))
(define (propagate) (if (empty-agenda? the-agenda) 'done
					 (let ((first-item (first-agenda-item the-agenda)))
					  (first-item) (remove-first-agenda-item! the-agenda) (propagate))))
(define (probe name wire)
 (add-action! wire (lambda () (newline) (display name) (display " ") (display (current-time the-agenda)) 
										(display "  New-value = ") (display (get-signal wire)))))
(define (make-agenda) (list 0))
(define the-agenda (make-agenda))
(define invert-delay 2) (define and-gate-delay 3) (define or-gate-delay 5)
(define input-1 (make-wire)) (define input-2 (make-wire)) (define sum (make-wire)) (define carry (make-wire))
(define (current-time agenda) (car agenda))
;3.31 the extra executed process is aimed at adding the action to the agenda
(define (make-time-segment time queue) (cons time queue))
(define (segment-time s) (car s))
(define (segment-queue s) (cdr s))
(define (set-current-time! agenda time) (set-car! agenda time))
(define (segments agenda) (cdr agenda))
(define (set-segments! agenda segments) (set-cdr! agenda segments))
(define (first-segment agenda) (car (segments agenda)))
(define (rest-segments agenda) (cdr (segments agenda)))
(define (empty-agenda?) (null? (rest-segments agenda)))
