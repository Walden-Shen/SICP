;3.12 (b) (b c d)
(define (append! x y) (set-cdr! (last-pair x) y) x)
(define (last-pair x) (if (null? (cdr x)) x (last-pair (cdr x))))
;3.13
(define (make-cycle x) (set-cdr! (last-pair x) x) x)
;3.14 a reverse function
(define (mystery x)
 (define (loop x y)
  (if (null? x) y
   (let ((temp (cdr x))) (set-cdr! x y) (loop temp x))))
 (loop x '()))
;3.15 i draw the box in my heart
;3.16
(define (count-pairs x) (if (not (pair? x)) 0 (+ (count-pairs (car x)) (count-pairs (cdr x)) 1)))
;3.17
(define (count-pairs x) (length (inner x '())))
(define (inner x memo-list)
 (if (and (pair? x) (false? (memq x memo-list)))
  (inner (car x) (inner (cdr x) (cons x memo-list))) memo-list))
;3.18 impressive
(define (loop? lst)
 (let ((identity (cons '() '())))
  (define (iter remain-list)
   	(cond   ((null? remain-list) #f)
	 		((eq? identity (car remain-list)) #t)
			(else (set-car! remain-list identity) (iter (cdr remain-list)))))
  (iter lst)))
;3.19
(define (loop-const? lst)
 (define (iter x y)
  (let ((x-walk (list-walk 1 x)) (y-walk (list-walk 2 y)))
     (cond  ((or (null? x-walk) (null? y-walk)) #f)
	  		((eq? x-walk y-walk) #t)
			(else (iter x-walk y-walk)))))
 (iter lst lst))
(define (list-walk step lst)
 (cond  ((null? lst) '())
  		((= step 0) lst)
		(else (list-walk (- step 1) (cdr lst)))))
;queue
(define make-queue (cons '() '()))
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))
(define (empty-queue? queue) (null? (front-ptr queue)))
(define (front-queue queue) (if (empty-queue? queue) (error "Front called with an empty queue" queue) 
							 (car (front-ptr queue))))
(define (insert-queue! queue item)
 (let ((new-pair (cons item '())))
  (cond ((empty-queue? queue) (set-front-ptr! queue new-pair) (set-rear-ptr! queue new-pair) queue)
   		(else (set-cdr! (rear-ptr queue) new-pair) (set-rear-ptr! queue new-pair) queue))))
(define (delete-queue! queue) (cond ((empty-queue? queue) (error "Delete called with an empty queue" queue))
			  					    (else (set-front-ptr! queue (cdr (front-ptr queue))) queue)))
;3.21
(define (print-queue queue) (front-ptr queue))
;3.22
(define (make-queue)
 (let ((front-ptr '()) (rear-ptr '()))
  (define (empty-queue?) (null? front-ptr))
  (define (set-front-ptr! item) (set! front-ptr item))
  (define (set-rear-ptr! item) (set! rear-ptr item))
  (define (insert-queue! item)
   (let ((new-pair (cons item '())))
	(cond ((empty-queue?) (set-front-ptr! new-pair) (set-rear-ptr! new-pair) front-ptr)
	 	  (else (set-cdr! rear-ptr new-pair) (set-rear-ptr! new-pair)))))
  (define (delete-queue!) (cond ((empty-queue?) (error "Delete called with an empty queue"))
						 	  (else (set-front-ptr! (cdr front-ptr)) front-ptr)))
  (define (dispatch m)
   (cond  ((eq? m 'insert-queue!) insert-queue!)
		  ((eq? m 'delete-queue!) delete-queue!)
		  (else (error "arg unmatched " m))))
  dispatch))
;3.23
(define (make-deque) (cons (cons '() '()) (cons '() '())))
(define (empty-deque? deque) (null? (car (front-deque deque))))
(define (front-deque deque) (car deque)) 
(define (rear-deque deque) (cdr deque))
(define (front-insert-deque! deque item)
 (let ((new-pair (cons item '())))
  (cond ((empty-deque? deque) 
		 (set-front-ptr! (front-deque deque) new-pair) (set-rear-ptr! (front-deque deque) new-pair)
		 (set-front-ptr! (rear-deque deque) new-pair) (set-rear-ptr! (rear-deque deque) new-pair) deque)
		(else (set-front-ptr! (front-deque deque) (cons item (car (front-deque deque))))
		 	  (set-cdr! (cdr (rear-deque deque)) new-pair)
		 	  (set-rear-ptr! (rear-deque deque) new-pair) deque))))
(define (rear-insert-deque! deque item)
 (let ((new-pair (cons item '())))
  (cond ((empty-deque? deque)
		 (set-front-ptr! (front-deque deque) new-pair) (set-rear-ptr! (front-deque deque) new-pair)
		 (set-front-ptr! (rear-deque deque) new-pair) (set-rear-ptr! (rear-deque deque) new-pair) deque)
   		(else (set-front-ptr! (rear-deque deque) new-pair) (set-cdr! (cdr (front-deque deque)) new-pair)
		 (set-rear-ptr! (front-deque deque) new-pair) deque))))
(define (front-delete-deque! deque)
 (cond  ((empty-deque? deque) (error "Delete called with an empty queue"))
  		(else (set-front-ptr! (front-deque deque) (rear-ptr (front-deque deque)))
		 	  (set-rear-ptr! (rear-deque deque) (front-ptr (front-deque deque))) (front-deque deque))))

 
