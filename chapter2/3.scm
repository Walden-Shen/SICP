;quote
(define (memq item x)
 (cond  ((null? x) #f)
  		((eq? item (car x)) x)
		(else (memq item (cdr x)))))
;2.53 simple
;2.54 
(define (equal? a b)
 (cond  ((and (not (pair? a)) (not (pair? b))) (eq? a b))
  		((and (pair? a) (pair? b)) (and (equal? (car a) (car b)) (equal? (cdr a) (cdr b))))
		(else #f)))
;2.55 (quote (quote abracadabra))
;differrentiation program
(define (deriv exp var)
 (cond  ((number? exp) 0)
  		((variable? exp) (if (same-variable? exp var) 1 0))
		((sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var)))
		((product? exp) (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
								  (make-product (deriv (multiplier exp) var) (multiplicand exp))))
		((exponentiation? exp) (make-product (make-exponentiation (base exp) (exponent exp)) 
												 (deriv (base exp) var)))
		(else (error "unknown expression type -- deriv" exp))))
(define (=number? exp num) (and (number? exp) (eq? exp num)))
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2) (and (variable? v1) (variable? v2) (eq? v1 v2)))
;2.57
(define (single-operand? x) (eq? (cdr x) '()))
(define (make-sum a1 . a2)
 (if (single-operand? a2)
  (let ((a2 (car a2)))
	 (cond  ((=number? a1 0) a2)
			((=number? a2 0) a1)
			((and (number? a1) (number? a2)) (+ a1 a2))
			(else (list '+ a1 a2))))
  (cons '+ (cons a1 a2))))
(define (make-product m1 . m2)
 (if (single-operand? m2)
  (let ((m2 (car m2)))
	 (cond	((or (=number? m1 0) (=number? m2 0)) 0)
			((=number? m1 1) m2)
			((=number? m2 1) m1)
			((and (number? m1) (number? m2)) (* m1 m2))
			(else (list '* m1 m2))))
  (cons '* (cons m1 m2))))
(define (sum? x) (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s)
 (let ((tail-operand (cddr s)))
  (if (single-operand? tail-operand) (car tail-operand) (apply make-sum tail-operand))))
(define (product? x) (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p)
 (let ((tail-operand (cddr p)))
  (if (single-operand? tail-operand) (car tail-operand) (apply make-product tail-operand))))
;2.56
(define (exponentiation? x) (and (pair? x) (eq? (car x) '**)))
(define (base e) (cadr e))
(define (exponent e) (caddr e))
(define (make-exponentiation e1 e2)
 (cond  ((=number? e2 1) 1)
  		((=number? e2 2) e1)
		(else (list '* e2 (list '** e1 (- e2 1))))))
;2.57
;set
(define (element-of-set? x set)
 (cond 	((null? set) #f)
  		((eq? x (car set)) #t)
		(else (element-of-set? x (cdr set)))))
(define (adjoin-set x set) (if (element-of-set? x set) set (cons x set)))
(define (intersection-set set1 set2) 
 (cond  ((or (null? set1) (null? set2)) '())
  		((element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2)))
		(else (intersection-set (cdr set1) set2))))
;2.59
(define (union-set set1 set2)
 (define (anx result set)
  (if (null? set) result (anx (adjoin-set (car set) result) (cdr set))))
 (anx set1 set2))
;2.60
(define (element-of-set-dup? x set) (element-of-set? x set))
(define (adjoin-set-dup x set) (cons x set))
(define (union-set-dup set1 set2) (iter (append set1 set2) '()))
(define (iter input result)
 (if (null? input) (reverse result)
  (let ((current-element (car input)) (remain-element (cdr input)))
   (if (element-of-set? current-element result)
	(iter remain-element result)
	(iter remain-element (cons current-element result))))))
(define (intersection-set-dup set1 set2)
