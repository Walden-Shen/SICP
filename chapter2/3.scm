;quote
(define (memq item x)
 (cond  ((null? x) #f)
  		((eq? item (car x)) x)
		(else (memq item (cdr x)))))
;2.53 simple
;2.54 
(define (equal? a b)
 (cond  ((and (not (pair? a)) (not (pair? b))) (eq? a b))
  		((and (pair? a) (pair? b)) (and (equal? (car a) (car b)) (equal? (cdr a) (cdr b))))
		(else #f)))
;2.55 (quote (quote abracadabra))
;differrentiation program
(define (deriv exp var)
 (cond  ((number? exp) 0)
  		((variable? exp) (if (same-variable? exp var) 1 0))
		((sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var)))
		((product? exp) (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
								  (make-product (deriv (multiplier exp) var) (multiplicand exp))))
		((exponentiation? exp) (make-product (make-exponentiation (base exp) (exponent exp)) 
												 (deriv (base exp) var)))
		(else (error "unknown expression type -- deriv" exp))))
(define (=number? exp num) (and (number? exp) (eq? exp num)))
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2) (and (variable? v1) (variable? v2) (eq? v1 v2)))
;2.57
(define (single-operand? x) (eq? (cdr x) '()))
(define (make-sum a1 . a2)
 (if (single-operand? a2)
  (let ((a2 (car a2)))
	 (cond  ((=number? a1 0) a2)
			((=number? a2 0) a1)
			((and (number? a1) (number? a2)) (+ a1 a2))
			(else (list '+ a1 a2))))
  (cons '+ (cons a1 a2))))
(define (make-product m1 . m2)
 (if (single-operand? m2)
  (let ((m2 (car m2)))
	 (cond	((or (=number? m1 0) (=number? m2 0)) 0)
			((=number? m1 1) m2)
			((=number? m2 1) m1)
			((and (number? m1) (number? m2)) (* m1 m2))
			(else (list '* m1 m2))))
  (cons '* (cons m1 m2))))
(define (sum? x) (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s)
 (let ((tail-operand (cddr s)))
  (if (single-operand? tail-operand) (car tail-operand) (apply make-sum tail-operand))))
(define (product? x) (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p)
 (let ((tail-operand (cddr p)))
  (if (single-operand? tail-operand) (car tail-operand) (apply make-product tail-operand))))
;2.56
(define (exponentiation? x) (and (pair? x) (eq? (car x) '**)))
(define (base e) (cadr e))
(define (exponent e) (caddr e))
(define (make-exponentiation e1 e2)
 (cond  ((=number? e2 1) 1)
  		((=number? e2 2) e1)
		(else (list '* e2 (list '** e1 (- e2 1))))))
;2.57
;set
(define (element-of-set? x set)
 (cond 	((null? set) #f)
  		((eq? x (car set)) #t)
		(else (element-of-set? x (cdr set)))))
(define (adjoin-set x set) (if (element-of-set? x set) set (cons x set)))
(define (intersection-set set1 set2) 
 (cond  ((or (null? set1) (null? set2)) '())
  		((element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2)))
		(else (intersection-set (cdr set1) set2))))
;2.59
(define (union-set set1 set2)
 (define (anx result set)
  (if (null? set) result (anx (adjoin-set (car set) result) (cdr set))))
 (anx set1 set2))
;2.60
(define (element-of-set-dup? x set) (element-of-set? x set))
(define (adjoin-set-dup x set) (cons x set))
(define (union-set-dup set1 set2) (iter (append set1 set2) '()))
(define (iter input result)
 (if (null? input) (reverse result)
  (let ((current-element (car input)) (remain-element (cdr input)))
   (if (element-of-set? current-element result)
	(iter remain-element result)
	(iter remain-element (cons current-element result))))))
(define (intersection-set-dup set1 set2)
 (define (iter input result)
  (if (null? input) (reverse result)
   (let ((current-element (car input)) (remain-element (cdr input)))
	(if (and (element-of-set? current-element set2) (not (element-of-set? current-element result)))
	 (iter remain-element (cons current-element result))
	 (iter remain-element result)))))
 (iter set1 '()))
;ordered set
(define (element-of-ordered-set? x set)
 (cond  ((null? set) #f)
  		((= x (car set)) #t)
		((> x (car set)) #f)
		(else (element-of-ordered-set? x (cdr set)))))
(define (intersection-ordered-set set1 set2) ;the ancillary function is unnecessary :p
 (define (iter set1 set2 result)
  (if (or (null? set1) (null? set2)) (reverse result)
   (cond ((= (car set1) (car set2)) (iter (cdr set1) (cdr set2) (cons (car set1) result)))
		 ((> (car set1) (car set2)) (iter set1 (cdr set2) result))
		 (else (iter (cdr set1) set2 result)))))
 (iter set1 set2 '()))
;2.61
(define (adjoin-ordered-set x set)
 (cond  ((null? set) (list x))
  		((= x (car set)) set)
		((< x (car set)) (cons x set))
		(else (cons (car set) (adjoin-ordered-set x (cdr set))))))
;2.62
(define (union-ordered-set set1 set2)
 (if (or (null? set1) (null? set2)) (append set1 set2)
  (let ((a (car set1)) (b (car set2)))
  	(cond ((= a b) (cons a (union-ordered-set (cdr set1) (cdr set2))))
   		  ((> a b) (cons b (union-ordered-set set1 (cdr set2))))
		  (else (cons a (union-ordered-set (cdr set1) set2)))))))
;tree
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left-branch right-branch) (list entry left-branch right-branch))
(define (element-of-tree? x tree)
 (cond  ((null? tree) #f)
  		((= x (entry tree)) #t)
		((> x (entry tree)) (element-of-tree? x (right-branch tree)))
		((< x (entry tree)) (element-of-tree? x (left-branch tree)))))
(define (adjoin-tree x tree)
 (cond  ((null? tree) (make-tree x '() '()))
		((= x (entry tree)) tree)
		((> x (entry tree)) (make-tree (entry tree) (left-branch tree) (adjoin-tree x (right-branch tree))))
		(else (make-tree (entry tree) (adjoin-tree x (left-branch tree)) (right-branch tree)))))
;2.63
(define (tree->list-1 tree)  ;n^2
 (if (null? tree) '() 
  (append (tree->list-1 (left-branch tree)) (cons (entry tree) (tree->list-1 (right-branch tree))))))
(define (tree->list-2 tree)     ;n
 (define (copy-to-list tree result-list)
  (if (null? tree) result-list 
   (copy-to-list (left-branch tree) (cons (entry tree) (copy-to-list (right-branch tree) result-list)))))
 (copy-to-list tree '()))
;2.64
(define (list->tree elements) (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
 (if (= n 0) (cons '() elts)
  (let ((left-size (quotient (- n 1) 2)))
   (let ((left-result (partial-tree elts left-size)))
    (let ((left-tree (car left-result)) (non-left-elts (cdr left-result)) (right-size (- n (+ left-size 1))))
	 (let ((this-entry (car non-left-elts)) (right-result (partial-tree (cdr non-left-elts) right-size)))
	  (let ((right-tree (car right-result)) (remaining-elts (cdr right-result)))
	   (cons (make-tree this-entry left-tree right-tree) remaining-elts))))))))
;2.65
(define (union-tree tree1 tree2) (list->tree (union-ordered-set (tree->list-2 tree1) (tree->list-2 tree2))))
(define (intersection-tree tree1 tree2) (list->tree (intersection-ordered-set (tree->list-2 tree1) (tree->list-2 tree2))))
;2.66
(define (lookup given-key tree-of-records)
 (cond  ((null? tree-of-records) #f)
  		((= given-key (key (entry tree-of-records))) (entry tree-of-records))
		((< given-key (key (entry tree-of-records))) (lookup given-key (left-branch tree-of-records)))
		(else (lookup given-key (right-branch tree-of-records)))))
;huffman tree
(define (make-leaf symbol weight) (list 'leaf symbol weight))
(define (leaf? object) (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
(define (make-code-tree left right) (list left right (append (symbol left) (symbol right)) (+ (weight left) (weight right))))
(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))
(define (symbols tree) (if (leaf? tree) (list (symbol-leaf tree)) (caddr tree)))
(define (weight tree) (if (leaf? tree) (weight-leaf tree) (cadddr tree)))

