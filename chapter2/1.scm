;2.1 rational number
(define (gcd a b) (if (= b 0) a (gcd b (remainder a b))))
(define (make-rat n d) (let ((g (gcd n d)))
						(if (negative? (* n d))
						 (cons (- (abs (/ n g))) (abs (/ d g)))
						 (cons (abs (/ n g)) (abs (/ d g))))))
;criteria version
(define (make-rat n d) (if (< d 0) (cons (- n) (- d)) (cons n d)))
(define (numer x) (car x))
(define (denom x) (cdr x))
(define (add-rat x y)
 (make-rat (+ (* (numer x) (denom y))
			  (* (numer y) (denom x)))
  		   (* (denom x) (denom y))))
(define (sub-rat x y)
 (make-rat (- (* (numer x) (denom y))
			  (* (numer y) (denom x)))
		   (* (denom x) (denom y))))
(define (mul-rat x y)
 (make-rat (* (numer x) (numer y))
  		   (* (denom x) (denom y))))
(define (div-rat x y)
 (make-rat (* (numer x) (denom y))
  		   (* (denom x) (numer y))))
(define (equal-rat? x y)
 (= (* (numer x) (denom y))
    (* (numer y) (denom x))))
(define (print-rat x) (newline) (display (numer x)) (display "/") (display (denom x)))
;2.2
(define (make-point a b) (cons a b))
(define (x-point point) (car point))
(define (y-point point) (cdr point))
(define (make-segment pointA pointB) (cons pointA pointB))
(define (start-segment segment) (car segment))
(define (end-segment segment) (cdr segment))
(define (average a b) (/ (+ a b)))
(define (midpoint-segment segment) (cons (average (x-point (start-segment segment)) (x-point (end-segment segment)))
										 (average (y-point (start-segment segment)) (y-point (end-segment segment)))))
;2.3
(define (make-rectangle segmentA segmentB) (cons segmentA segmentB))
(define (segmentA rectangle) (car rectangle))
(define (segmentB rectangle) (cdr rectangle))
(define (length segment) (sqrt (+ (square (abs (- (x-point (start-segment segment)) (x-point (end-segment segment))))
								  (square (abs (- (y-point (start-segment segment)) (y-point (end-segment segment)))))))))
(define (perimeter rectangle) (* 2 (+ (length (segmentA rectangle)) (length (segmentB rectangle)))))
(define (area rectangle) (* (length (segmentA rectangle)) (length (segmentB rectangle))))

;new cons
(define (new-cons x y)
 (define (dispatch m)
  (cond ((= m 0) x)
   		((= m 1) y)
		(else (error "Argument not 0 or 1"))))
 dispatch)
(define (new-car z) (z 0))
(define (new-cdr z) (z 1))

;2.4
(define (new-cons x y) (lambda (m) (m x y)))
(define (new-car z) (z (lambda (p q) p)))
(define (new-cdr z) (z (lambda (p q) q)))
;2.5
(define (pow x n) (if (= n 0) 1 (* x (pow x (- n 1)))))
(define (new-cons a b) (* (pow 2 a) (pow 3 b)))
(define (new-car z) (if (= (remainder z 2) 1) 0 (+ 1 (new-car (/ z 2)))))
(define (new-cdr z) (if (not (= (remainder z 3) 0)) 0 (+ 1 (new-cdr (/ z 3)))))
;2.6
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n) (lambda (f) (lambda (x) (f ((n f) x)))))
(define one (lambda (f) (lambda (x) (f x))))
(define two (lambda (f) (lambda (x) (f (f x)))))
(define (+ (lambda (m) (lambda (n)) (lambda (f) (lambda (x) (m f (n f x)))))))
;2.7 ~ 2.16 have already been finished in the cs61a Berkeley
